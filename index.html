<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Operating Systems – Compute & IO Quiz</title>

<style>
body {
    font-family: Arial, sans-serif;
    max-width: 980px;
    margin: 20px auto;
    padding: 20px;
    background-color: #f4f6f9;
    color: #333;
}
h1 { text-align: center; }
.question {
    background: #fff;
    padding: 22px;
    margin-bottom: 26px;
    border-radius: 10px;
    box-shadow: 0 3px 8px rgba(0,0,0,0.1);
}
.question h3 {
    margin-top: 0;
    color: #2c3e50;
}
label {
    display: block;
    margin: 10px 0;
    cursor: pointer;
}
button {
    display: block;
    width: 280px;
    margin: 40px auto;
    padding: 14px;
    font-size: 1.1em;
    background-color: #3498db;
    color: #fff;
    border: none;
    border-radius: 6px;
    cursor: pointer;
}
#result {
    display: none;
    margin-top: 40px;
    background: #ecf0f1;
    padding: 20px;
    border-radius: 10px;
    text-align: center;
}
</style>
</head>

<body>

<h1>Operating Systems – Compute & IO Quiz</h1>

<form id="quizForm">

<!-- ================= TRUE / FALSE ================= -->

<div class="question">
<h3>Question 1</h3>
<p>The client–server application described in this context uses BSD (network) sockets as the main communication mechanism between processes.</p>
<label><input type="radio" name="q1" value="true" required> True</label>
<label><input type="radio" name="q1" value="false"> False</label>
</div>

<div class="question">
<h3>Question 2</h3>
<p>The client reads commands from standard input, meaning it performs <code>read()</code> system calls on file descriptor 0.</p>
<label><input type="radio" name="q2" value="true" required> True</label>
<label><input type="radio" name="q2" value="false"> False</label>
</div>

<div class="question">
<h3>Question 3</h3>
<p>To initiate a connection to the server, the client uses the <code>accept()</code> system call.</p>
<label><input type="radio" name="q3" value="true" required> True</label>
<label><input type="radio" name="q3" value="false"> False</label>
</div>

<div class="question">
<h3>Question 4</h3>
<p>After connecting to the server, the client does not need to call <code>recv()</code> (or <code>read()</code>) in order to receive the output of the executed command.</p>
<label><input type="radio" name="q4" value="true" required> True</label>
<label><input type="radio" name="q4" value="false"> False</label>
</div>

<div class="question">
<h3>Question 5</h3>
<p>If the <code>recv()</code> system call returns 0 on the server side, this indicates that the client has closed the connection.</p>
<label><input type="radio" name="q5" value="true" required> True</label>
<label><input type="radio" name="q5" value="false"> False</label>
</div>

<div class="question">
<h3>Question 6</h3>
<p>In a concurrent server, each connected client is handled using a distinct connected socket on the server side.</p>
<label><input type="radio" name="q6" value="true" required> True</label>
<label><input type="radio" name="q6" value="false"> False</label>
</div>

<div class="question">
<h3>Question 7</h3>
<p>The listening socket (the one on which <code>listen()</code> is called) is used to send command output back to the client.</p>
<label><input type="radio" name="q7" value="true" required> True</label>
<label><input type="radio" name="q7" value="false"> False</label>
</div>

<div class="question">
<h3>Question 8</h3>
<p>A “fork-per-client” server architecture, where each new client is handled by a separate process, is a valid design choice.</p>
<label><input type="radio" name="q8" value="true" required> True</label>
<label><input type="radio" name="q8" value="false"> False</label>
</div>

<div class="question">
<h3>Question 9</h3>
<p>In a fork-per-client server, the child process must call <code>accept()</code> again in order to use the already accepted connection.</p>
<label><input type="radio" name="q9" value="true" required> True</label>
<label><input type="radio" name="q9" value="false"> False</label>
</div>

<div class="question">
<h3>Question 10</h3>
<p>In a multi-process server implementation, processes are often in the BLOCKED state while waiting for I/O operations to complete.</p>
<label><input type="radio" name="q10" value="true" required> True</label>
<label><input type="radio" name="q10" value="false"> False</label>
</div>

<div class="question">
<h3>Question 11</h3>
<p>The <code>dup2()</code> system call can be used to redirect the standard output of a process to a socket.</p>
<label><input type="radio" name="q11" value="true" required> True</label>
<label><input type="radio" name="q11" value="false"> False</label>
</div>

<!-- ================= MULTIPLE CHOICE ================= -->

<div class="question">
<h3>Question 12</h3>
<p>Can BSD sockets be used for communication between processes running on the same machine?</p>
<label><input type="radio" name="q12" value="a" required>No, BSD sockets are only for remote communication</label>
<label><input type="radio" name="q12" value="b">Yes, but only on port 80</label>
<label><input type="radio" name="q12" value="c">Yes, using any network interface</label>
<label><input type="radio" name="q12" value="d">Yes, using BSD sockets bound to local files (UNIX domain sockets)</label>
</div>

<div class="question">
<h3>Question 13</h3>
<p>Is it possible to use shared memory for communication between two unrelated processes?</p>
<label><input type="radio" name="q13" value="a" required>Yes, by using file-backed shared memory mappings</label>
<label><input type="radio" name="q13" value="b">Yes, by using sockets</label>
<label><input type="radio" name="q13" value="c">No, only related processes can share memory</label>
<label><input type="radio" name="q13" value="d">Yes, but only with anonymous mappings</label>
</div>

<div class="question">
<h3>Question 14</h3>
<p>What is a key advantage of using processes instead of threads when modularizing an application?</p>
<label><input type="radio" name="q14" value="a" required>Processes share memory more easily than threads</label>
<label><input type="radio" name="q14" value="b">Processes provide better isolation through separate virtual address spaces</label>
<label><input type="radio" name="q14" value="c">There is no advantage of processes over threads</label>
<label><input type="radio" name="q14" value="d">Only processes can run on multiple CPUs</label>
</div>

<div class="question">
<h3>Question 15</h3>
<p>Which statement correctly describes a difference between a UNIX socket and a regular file?</p>
<label><input type="radio" name="q15" value="a" required>UNIX sockets do not have file descriptors</label>
<label><input type="radio" name="q15" value="b">UNIX sockets are memory-backed, while files are typically storage-backed</label>
<label><input type="radio" name="q15" value="c">UNIX sockets are only for network communication</label>
<label><input type="radio" name="q15" value="d">UNIX sockets can be used only in distributed systems</label>
</div>

<div class="question">
<h3>Question 16</h3>
<p>What is an advantage of using threads instead of processes when designing a modular application?</p>
<label><input type="radio" name="q16" value="a" required>Threads are always faster than processes</label>
<label><input type="radio" name="q16" value="b">There is no advantage of threads over processes</label>
<label><input type="radio" name="q16" value="c">Threads communicate using TLS</label>
<label><input type="radio" name="q16" value="d">Threads share the same virtual address space</label>
</div>

<div class="question">
<h3>Question 17</h3>
<p>Why are signals considered asynchronous in UNIX-like operating systems?</p>
<label><input type="radio" name="q17" value="a" required>There is no synchronization with the OS</label>
<label><input type="radio" name="q17" value="b">Signals use asynchronous sockets</label>
<label><input type="radio" name="q17" value="c">Signals are not asynchronous</label>
<label><input type="radio" name="q17" value="d">A registered handler is invoked whenever the signal is delivered</label>
</div>

<div class="question">
<h3>Question 18</h3>
<p>UNIX sockets, pipes, and FIFOs are best described as:</p>
<label><input type="radio" name="q18" value="a" required>IPC mechanisms using user-space buffers</label>
<label><input type="radio" name="q18" value="b">IPC mechanisms using kernel-space buffers accessed via file descriptors</label>
<label><input type="radio" name="q18" value="c">IPC mechanisms that do not use memory</label>
<label><input type="radio" name="q18" value="d">Shared-memory IPC mechanisms</label>
</div>

<div class="question">
<h3>Question 19</h3>
<p>Can a pipe still be used after the child process calls <code>execve()</code>?</p>
<label><input type="radio" name="q19" value="a" required>Yes, because file descriptors are preserved by default</label>
<label><input type="radio" name="q19" value="b">No, only standard descriptors remain open</label>
<label><input type="radio" name="q19" value="c">No, because the virtual address space changes</label>
<label><input type="radio" name="q19" value="d">No, because all file descriptors are closed</label>
</div>

<div class="question">
<h3>Question 20</h3>
<p>What is a fundamental difference between UNIX domain sockets and network (BSD) sockets?</p>
<label><input type="radio" name="q20" value="a" required>BSD sockets can be used for distributed applications, UNIX sockets are local</label>
<label><input type="radio" name="q20" value="b">BSD sockets do not use file descriptors</label>
<label><input type="radio" name="q20" value="c">UNIX sockets do not use file descriptors</label>
<label><input type="radio" name="q20" value="d">BSD sockets are always faster</label>
</div>

<div class="question">
<h3>Question 21</h3>
<p>What is a similarity between a UNIX socket and a regular file?</p>
<label><input type="radio" name="q21" value="a" required>Both are backed by disk storage</label>
<label><input type="radio" name="q21" value="b">Both provide persistent storage</label>
<label><input type="radio" name="q21" value="c">Both have an entry in the file system</label>
<label><input type="radio" name="q21" value="d">Both are slow IPC mechanisms</label>
</div>

<div class="question">
<h3>Question 22</h3>
<p>What is the main difference between a pipe and a FIFO?</p>
<label><input type="radio" name="q22" value="a" required>There is no difference</label>
<label><input type="radio" name="q22" value="b">Pipes require related processes, FIFOs do not</label>
<label><input type="radio" name="q22" value="c">Pipes are user-space, FIFOs kernel-space</label>
<label><input type="radio" name="q22" value="d">Pipes use descriptors, FIFOs use signals</label>
</div>

<div class="question">
<h3>Question 23</h3>
<p>Can semaphores be used as an inter-thread communication mechanism?</p>
<label><input type="radio" name="q23" value="a" required>Yes, for exclusive access to shared resources</label>
<label><input type="radio" name="q23" value="b">No, wait/post cannot be used in threads</label>
<label><input type="radio" name="q23" value="c">Yes, by using wait() and post() in different threads</label>
<label><input type="radio" name="q23" value="d">No, because semaphores cannot transmit data</label>
</div>

<div class="question">
<h3>Question 24</h3>
<p>Why is modularity an important principle in application design?</p>
<label><input type="radio" name="q24" value="a" required>All of the above</label>
<label><input type="radio" name="q24" value="b">Modular code is easier to debug</label>
<label><input type="radio" name="q24" value="c">Modular applications are easier to maintain</label>
<label><input type="radio" name="q24" value="d">Modular code can be reused</label>
</div>

<div class="question">
<h3>Question 25</h3>
<p>Which inter-process communication mechanism is generally the most efficient?</p>
<label><input type="radio" name="q25" value="a" required>Message passing</label>
<label><input type="radio" name="q25" value="b">Signals</label>
<label><input type="radio" name="q25" value="c">Reading and writing files</label>
<label><input type="radio" name="q25" value="d">Shared memory</label>
</div>

<div class="question">
<h3>Question 26</h3>
<p>Which of the following best defines a signal in UNIX-like operating systems?</p>
<label><input type="radio" name="q26" value="a" required>An asynchronous notification sent to a process</label>
<label><input type="radio" name="q26" value="b">An interrupt generated by the MMU</label>
<label><input type="radio" name="q26" value="c">A mechanism used only to terminate processes</label>
<label><input type="radio" name="q26" value="d">A synchronization primitive</label>
</div>

<button type="submit">Submit Answers</button>
</form>

<div id="result"></div>

<script>
const correct = {
q1:"true",q2:"true",q3:"false",q4:"false",q5:"true",q6:"true",
q7:"false",q8:"true",q9:"false",q10:"true",q11:"true",
q12:"d",q13:"a",q14:"b",q15:"b",q16:"d",q17:"d",q18:"b",
q19:"a",q20:"a",q21:"c",q22:"b",q23:"c",q24:"a",q25:"d",q26:"a"
};

const explanations = {
q1: "The client uses BSD sockets to communicate with the server over the network.",
q2: "Standard input is file descriptor 0, so reading commands uses read(0,...).",
q3: "accept() is called by the server, not the client; the client calls connect().",
q4: "The client must call recv() or read() to receive data sent by the server.",
q5: "recv() returning 0 indicates the peer has closed the connection.",
q6: "Each client connection gets a distinct socket on the server side.",
q7: "The listening socket is only for accepting new connections, not sending data.",
q8: "Fork-per-client is a common architecture for concurrent servers.",
q9: "Child process uses the accepted socket; it does not call accept() again.",
q10: "Processes waiting for I/O are typically BLOCKED until I/O completes.",
q11: "dup2() can redirect standard output to any file descriptor, including sockets.",
q12: "UNIX domain sockets allow BSD sockets to communicate locally via file paths.",
q13: "File-backed shared memory allows unrelated processes to share memory.",
q14: "Processes provide isolation through separate virtual address spaces.",
q15: "UNIX sockets are memory-backed, files are storage-backed.",
q16: "Threads share the same virtual address space, allowing easy communication.",
q17: "Signals are asynchronous because they can arrive at any time, triggering a handler.",
q18: "They use kernel-space buffers accessed through file descriptors.",
q19: "File descriptors remain open across execve(), so pipes can still be used.",
q20: "UNIX sockets are local; BSD sockets can be used for distributed applications.",
q21: "Both UNIX sockets and files have entries in the filesystem.",
q22: "Pipes require related processes; FIFOs (named pipes) can be used by unrelated processes.",
q23: "Semaphores can be used between threads using wait/post for synchronization.",
q24: "Modularity allows easier debugging, maintenance, and code reuse.",
q25: "Shared memory is typically the fastest IPC mechanism.",
q26: "A signal is an asynchronous notification sent to a process."
};

document.getElementById("quizForm").onsubmit = e => {
    e.preventDefault();
    let score = 0;

    for (let q in correct) {
        const sel = document.querySelector(`input[name=${q}]:checked`);
        const questionDiv = document.querySelector(`input[name=${q}]`).closest(".question");

        // Remove previous feedback if any
        const prevFeedback = questionDiv.querySelector(".feedback");
        if (prevFeedback) prevFeedback.remove();

        const feedback = document.createElement("div");
        feedback.className = "feedback";
        feedback.style.marginTop = "10px";
        feedback.style.padding = "10px";
        feedback.style.borderRadius = "6px";

        if (sel && sel.value === correct[q]) {
            score++;
            feedback.style.backgroundColor = "#d4edda";
            feedback.style.color = "#155724";
            feedback.innerHTML = `Correct! ✅<br>${explanations[q]}`;
        } else {
            feedback.style.backgroundColor = "#f8d7da";
            feedback.style.color = "#721c24";
            const userAns = sel ? sel.value.toUpperCase() : "No answer";
            const correctAns = correct[q].toUpperCase();
            feedback.innerHTML = `Incorrect ❌ (Your answer: ${userAns}, Correct answer: ${correctAns})<br>${explanations[q]}`;
        }

        questionDiv.appendChild(feedback);
    }

    document.getElementById("result").innerHTML =
        `<h2>Your Score: ${score}/26</h2>`;
    document.getElementById("result").style.display = "block";

    // Scroll to the top of the results
    window.scrollTo({ top: 0, behavior: 'smooth' });
};
</script>


</body>
</html>
